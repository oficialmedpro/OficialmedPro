/**
 * üü£ TICKET M√âDIO SERVICE
 * 
 * Servi√ßo espec√≠fico para buscar as m√©tricas de Ticket M√©dio:
 * 1. Ticket M√©dio do Per√≠odo (valor total / quantidade total de oportunidades ganhas no per√≠odo)
 * 2. Ticket M√©dio Geral (valor total / quantidade total de todas as oportunidades ganhas)
 */

// Configura√ß√µes do Supabase
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseServiceKey = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY;
const supabaseSchema = import.meta.env.VITE_SUPABASE_SCHEMA || 'api';

/**
 * üü£ FUN√á√ÉO PARA BUSCAR TODOS OS REGISTROS COM PAGINA√á√ÉO RECURSIVA
 * 
 * @param {string} url - URL base da query
 * @param {Object} headers - Headers da requisi√ß√£o
 * @returns {Array} Todos os registros encontrados
 */
const fetchAllRecords = async (url, headers) => {
  const pageSize = 1000; // Tamanho padr√£o da p√°gina do Supabase
  let allRecords = [];
  let offset = 0;
  let hasMore = true;

  console.log('üìÑ Iniciando pagina√ß√£o para URL:', url);

  while (hasMore) {
    const paginatedUrl = `${url}`;
    const paginationHeaders = {
      ...headers,
      'Range': `${offset}-${offset + pageSize - 1}`
    };

    try {
      const response = await fetch(paginatedUrl, {
        method: 'GET',
        headers: paginationHeaders
      });

      if (!response.ok) {
        console.error(`‚ùå Erro na p√°gina ${Math.floor(offset / pageSize) + 1}:`, response.status);
        break;
      }

      const pageData = await response.json();
      allRecords = allRecords.concat(pageData);

      console.log(`üìÑ P√°gina ${Math.floor(offset / pageSize) + 1}: ${pageData.length} registros | Total: ${allRecords.length}`);

      // Se retornou menos que o tamanho da p√°gina, n√£o h√° mais dados
      if (pageData.length < pageSize) {
        hasMore = false;
      } else {
        offset += pageSize;
      }

      // Verificar Content-Range header para confirmar se h√° mais dados
      const contentRange = response.headers.get('Content-Range');
      if (contentRange) {
        const match = contentRange.match(/(\d+)-(\d+)\/(\d+|\*)/);
        if (match) {
          const [, , end, total] = match;
          if (total !== '*' && parseInt(end) >= parseInt(total) - 1) {
            hasMore = false;
          }
        }
      }

    } catch (error) {
      console.error(`‚ùå Erro ao buscar p√°gina ${Math.floor(offset / pageSize) + 1}:`, error);
      break;
    }
  }

  console.log(`‚úÖ Pagina√ß√£o conclu√≠da: ${allRecords.length} registros totais`);
  return allRecords;
};

/**
 * üü£ BUSCAR M√âTRICAS DE TICKET M√âDIO
 * 
 * @param {string} startDate - Data inicial (formato YYYY-MM-DD)
 * @param {string} endDate - Data final (formato YYYY-MM-DD)
 * @param {string} selectedFunnel - ID do funil selecionado
 * @param {string} selectedUnit - ID da unidade selecionada (formato [1], [2], etc.)
 * @param {string} selectedSeller - ID do vendedor selecionado
 * @param {string} selectedOrigin - Origem da oportunidade selecionada
 * @returns {Object} Objeto com as m√©tricas calculadas
 */
export const getTicketMedioMetrics = async (
  startDate = null, 
  endDate = null, 
  selectedFunnel = null, 
  selectedUnit = null, 
  selectedSeller = null, 
  selectedOrigin = null
) => {
  try {
    console.log('='.repeat(80));
    console.log('üü£ TicketMedioService: INICIANDO BUSCA DE M√âTRICAS');
    console.log('üìÖ Par√¢metros recebidos:');
    console.log('  - startDate:', startDate, typeof startDate);
    console.log('  - endDate:', endDate, typeof endDate);
    console.log('  - selectedFunnel:', selectedFunnel, typeof selectedFunnel);
    console.log('  - selectedUnit:', selectedUnit, typeof selectedUnit);
    console.log('  - selectedSeller:', selectedSeller, typeof selectedSeller);
    console.log('  - selectedOrigin:', selectedOrigin, typeof selectedOrigin);
    console.log('='.repeat(80));

    // Data de hoje para fallback
    const hoje = new Date().toISOString().split('T')[0];

    // Fallback para datas se n√£o estiverem definidas
    let dataInicio = startDate;
    let dataFim = endDate;
    
    if (!dataInicio || !dataFim || dataInicio === '' || dataFim === '') {
      dataInicio = hoje;
      dataFim = hoje;
      console.log('‚ö†Ô∏è TicketMedioService: Usando datas fallback (hoje):', { dataInicio, dataFim });
    } else {
      console.log('‚úÖ TicketMedioService: Usando datas fornecidas:', { dataInicio, dataFim });
    }

    // Construir filtros baseados nos par√¢metros
    let funilFilter = '';
    if (selectedFunnel && selectedFunnel !== 'all' && selectedFunnel !== 'TODOS' && selectedFunnel !== '' && selectedFunnel !== 'undefined') {
      funilFilter = `&funil_id=eq.${selectedFunnel}`;
      console.log('üîç TicketMedioService: Filtro de funil espec√≠fico aplicado:', funilFilter);
    } else {
      funilFilter = `&funil_id=in.(6,14)`;
      console.log('üîç TicketMedioService: Filtro de funil incluindo ambos (6 e 14):', funilFilter);
    }
    
    let unidadeFilter = '';
    if (selectedUnit && selectedUnit !== 'all' && selectedUnit !== '' && selectedUnit !== 'undefined') {
      const unidadeValue = selectedUnit.toString();
      const unidadeEncoded = encodeURIComponent(unidadeValue);
      
      unidadeFilter = `&unidade_id=eq.${unidadeEncoded}`;
      console.log('üîç Filtro unidade com colchetes codificados:', unidadeFilter);
      console.log('üîç Valor original:', unidadeValue, '-> Codificado:', unidadeEncoded);
    }
    
    let sellerFilter = '';
    if (selectedSeller && selectedSeller !== 'all' && selectedSeller !== '' && selectedSeller !== 'undefined' && selectedSeller !== 'TODOS') {
      sellerFilter = `&user_id=eq.${selectedSeller}`;
      console.log('üîç Filtro de vendedor aplicado:', { selectedSeller, sellerFilter });
    } else {
      console.log('üîç Sem filtro de vendedor:', { selectedSeller, type: typeof selectedSeller });
    }

    let originFilter = '';
    if (selectedOrigin && selectedOrigin !== 'all' && selectedOrigin !== '' && selectedOrigin !== 'undefined') {
      // Buscar o nome da origem na tabela origem_oportunidade
      try {
        const originResponse = await fetch(`${supabaseUrl}/rest/v1/origem_oportunidade?select=nome&id=eq.${selectedOrigin}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Authorization': `Bearer ${supabaseServiceKey}`,
            'apikey': supabaseServiceKey,
            'Accept-Profile': supabaseSchema,
          }
        });

        if (originResponse.ok) {
          const originData = await originResponse.json();
          if (originData && originData.length > 0) {
            const originName = originData[0].nome;
            
            // üå± ORIG√ÇNICO ‚Üí incluir tamb√©m NULL | üîé GOOGLE ADS ‚Üí incluir utm_source
            const lower = originName.toLowerCase();
            if (lower === 'org√¢nico' || lower === 'organico') {
              originFilter = `&or=(origem_oportunidade.eq.${encodeURIComponent(originName)},origem_oportunidade.is.null)`;
              console.log('üå± Filtro de origem Org√¢nico (incluindo NULL):', { selectedOriginId: selectedOrigin, originName, originFilter });
            } else if (lower === 'google ads' || lower === 'googleads') {
              originFilter = `&or=(origem_oportunidade.eq.${encodeURIComponent(originName)},utm_source.eq.google,utm_source.eq.GoogleAds)`;
              console.log('üîé Filtro de origem Google Ads (inclui utm_source google/GoogleAds):', { selectedOriginId: selectedOrigin, originName, originFilter });
            } else {
              originFilter = `&origem_oportunidade=eq.${encodeURIComponent(originName)}`;
              console.log('üîç Filtro de origem convertido:', { selectedOriginId: selectedOrigin, originName, originFilter });
            }
          } else {
            console.log('‚ö†Ô∏è Origem n√£o encontrada para ID:', selectedOrigin);
          }
        } else {
          console.log('‚ö†Ô∏è Erro ao buscar origem, usando ID diretamente:', selectedOrigin);
          originFilter = `&origem_oportunidade=eq.${encodeURIComponent(selectedOrigin)}`;
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro ao buscar origem, usando ID diretamente:', error);
        originFilter = `&origem_oportunidade=eq.${encodeURIComponent(selectedOrigin)}`;
      }
    }

    const filtrosCombinados = funilFilter + unidadeFilter + sellerFilter + originFilter;

    console.log('üîç Filtros constru√≠dos:');
    console.log('  - funilFilter:', funilFilter);
    console.log('  - unidadeFilter:', unidadeFilter);
    console.log('  - sellerFilter:', sellerFilter);
    console.log('  - originFilter:', originFilter);
    console.log('  - filtrosCombinados:', filtrosCombinados);

    // üü£ 1. TICKET M√âDIO DO PER√çODO - gain_date no per√≠odo + status="gain"
    const ticketMedioPeriodoUrl = `${supabaseUrl}/rest/v1/oportunidade_sprint?select=id,value&archived=eq.0&status=eq.gain&gain_date=gte.${dataInicio}&gain_date=lte.${dataFim}T23:59:59${filtrosCombinados}`;
    console.log('üîç URL Ticket M√©dio do Per√≠odo:', ticketMedioPeriodoUrl);

    // üü£ 2. TICKET M√âDIO GERAL - todas as oportunidades ganhas + status="gain"
    const ticketMedioGeralUrl = `${supabaseUrl}/rest/v1/oportunidade_sprint?select=id,value&archived=eq.0&status=eq.gain${filtrosCombinados}`;
    console.log('üîç URL Ticket M√©dio Geral:', ticketMedioGeralUrl);

    // üéØ 3. BUSCAR META DE TICKET M√âDIO - Tabela metas
    const unidadeParaMeta = selectedUnit && selectedUnit !== 'all' ? selectedUnit : '[1]';
    
    let metaTicketMedioUrl;
    
    // üéØ L√ìGICA DE META BASEADA NA SELE√á√ÉO E VENDEDOR
    if (selectedSeller && selectedSeller !== 'all' && selectedSeller !== '' && selectedSeller !== 'undefined') {
      // Vendedor espec√≠fico selecionado - buscar meta espec√≠fica do vendedor
      if (selectedFunnel && selectedFunnel !== 'all' && selectedFunnel !== 'TODOS' && selectedFunnel !== '' && selectedFunnel !== 'undefined') {
        // Funil + Vendedor espec√≠fico
        metaTicketMedioUrl = `${supabaseUrl}/rest/v1/metas?select=valor_da_meta&unidade_franquia=eq.${encodeURIComponent(unidadeParaMeta)}&dashboard=eq.ticket_medio_diario&funil=eq.${selectedFunnel}&vendedor_id=eq.${selectedSeller}`;
        console.log('üéØ Buscando meta espec√≠fica do vendedor e funil para ticket m√©dio:', selectedSeller, selectedFunnel);
      } else {
        // Apenas vendedor espec√≠fico - buscar AMBOS funis (6 e 14) e calcular m√©dia
        metaTicketMedioUrl = `${supabaseUrl}/rest/v1/metas?select=valor_da_meta&unidade_franquia=eq.${encodeURIComponent(unidadeParaMeta)}&dashboard=eq.ticket_medio_diario&funil=in.(6,14)&vendedor_id=eq.${selectedSeller}`;
        console.log('üéØ Buscando metas de ambos funis (6 e 14) para vendedor espec√≠fico - ticket m√©dio:', selectedSeller);
      }
    } else {
      // Sem vendedor espec√≠fico - buscar metas gerais
      if (selectedFunnel && selectedFunnel !== 'all' && selectedFunnel !== 'TODOS' && selectedFunnel !== '' && selectedFunnel !== 'undefined') {
        // Funil espec√≠fico selecionado - buscar meta espec√≠fica do funil
        metaTicketMedioUrl = `${supabaseUrl}/rest/v1/metas?select=valor_da_meta&unidade_franquia=eq.${encodeURIComponent(unidadeParaMeta)}&dashboard=eq.ticketmedio_oportunidades&funil=eq.${selectedFunnel}&vendedor_id=is.null`;
        console.log('üéØ Buscando meta espec√≠fica do funil para ticket m√©dio (geral):', selectedFunnel);
      } else {
        // Apenas unidade selecionada - buscar AMBOS funis (6 e 14) e calcular m√©dia
        metaTicketMedioUrl = `${supabaseUrl}/rest/v1/metas?select=valor_da_meta&unidade_franquia=eq.${encodeURIComponent(unidadeParaMeta)}&dashboard=eq.ticketmedio_oportunidades&funil=in.(6,14)&vendedor_id=is.null`;
        console.log('üéØ Buscando metas de ambos funis (6 e 14) para calcular m√©dia - ticket m√©dio (geral)');
      }
    }
    
    console.log('üîç URL Meta Ticket M√©dio:', metaTicketMedioUrl);

    // üü£ EXECUTAR QUERIES COM PAGINA√á√ÉO
    const baseHeaders = {
      'Accept': 'application/json',
      'Authorization': `Bearer ${supabaseServiceKey}`,
      'apikey': supabaseServiceKey,
      'Accept-Profile': supabaseSchema,
      'Prefer': 'count=exact'
    };

    // Executar queries com pagina√ß√£o em paralelo
    const [periodoData, geralData, metaResponse] = await Promise.all([
      fetchAllRecords(ticketMedioPeriodoUrl, baseHeaders),
      fetchAllRecords(ticketMedioGeralUrl, baseHeaders),
      fetch(metaTicketMedioUrl, {
        method: 'GET',
        headers: baseHeaders
      })
    ]);

    // Processar resultados
    let ticketMedioPeriodo = 0;
    let valorTotalPeriodo = 0;
    let quantidadePeriodo = 0;
    
    let ticketMedioGeral = 0;
    let valorTotalGeral = 0;
    let quantidadeGeral = 0;

    // 1. Ticket M√©dio do Per√≠odo - usando pagina√ß√£o
    if (periodoData && Array.isArray(periodoData)) {
      quantidadePeriodo = periodoData.length;
      valorTotalPeriodo = periodoData.reduce((total, opp) => {
        const valor = parseFloat(opp.value) || 0;
        return total + valor;
      }, 0);
      
      ticketMedioPeriodo = quantidadePeriodo > 0 ? valorTotalPeriodo / quantidadePeriodo : 0;
      console.log(`‚úÖ Ticket M√©dio do Per√≠odo: R$ ${ticketMedioPeriodo.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} (${quantidadePeriodo} oportunidades, R$ ${valorTotalPeriodo.toLocaleString('pt-BR', { minimumFractionDigits: 2 })})`);
    } else {
      console.error('‚ùå Erro ao buscar ticket m√©dio do per√≠odo com pagina√ß√£o');
    }

    // 2. Ticket M√©dio Geral - usando pagina√ß√£o
    if (geralData && Array.isArray(geralData)) {
      quantidadeGeral = geralData.length;
      valorTotalGeral = geralData.reduce((total, opp) => {
        const valor = parseFloat(opp.value) || 0;
        return total + valor;
      }, 0);
      
      ticketMedioGeral = quantidadeGeral > 0 ? valorTotalGeral / quantidadeGeral : 0;
      console.log(`‚úÖ Ticket M√©dio Geral: R$ ${ticketMedioGeral.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} (${quantidadeGeral} oportunidades, R$ ${valorTotalGeral.toLocaleString('pt-BR', { minimumFractionDigits: 2 })})`);
    } else {
      console.error('‚ùå Erro ao buscar ticket m√©dio geral com pagina√ß√£o');
    }

    // 3. Meta de Ticket M√©dio
    let metaTicketMedio = 0;
    if (metaResponse.ok) {
      const metaData = await metaResponse.json();
      if (metaData && metaData.length > 0) {
        if (selectedFunnel && selectedFunnel !== 'all' && selectedFunnel !== 'TODOS') {
          // Funil espec√≠fico - usar valor √∫nico
          metaTicketMedio = parseFloat(metaData[0].valor_da_meta) || 0;
          console.log(`‚úÖ Meta Ticket M√©dio (funil ${selectedFunnel}): R$ ${metaTicketMedio.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`);
        } else {
          // Unidade selecionada (ambos funis) - calcular M√âDIA das metas dos funis 6 e 14
          const somaMetas = metaData.reduce((total, meta) => {
            const valor = parseFloat(meta.valor_da_meta) || 0;
            return total + valor;
          }, 0);
          const quantidadeFunils = metaData.length;
          metaTicketMedio = quantidadeFunils > 0 ? somaMetas / quantidadeFunils : 0;
          console.log(`‚úÖ Meta Ticket M√©dio (m√©dia dos funis 6+14): R$ ${metaTicketMedio.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`);
          console.log(`üîç Detalhes: Soma=${somaMetas.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}, Qtd=${quantidadeFunils}, M√©dia=${metaTicketMedio.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`);
          console.log(`üîç Metas encontradas:`, metaData.map(m => ({ valor: m.valor_da_meta })));
        }
      } else {
        console.log('‚ö†Ô∏è Nenhuma meta encontrada para ticket m√©dio, usando valor padr√£o');
        metaTicketMedio = 0; // Valor padr√£o
      }
    } else {
      console.error('‚ùå Erro ao buscar meta de ticket m√©dio:', metaResponse.status);
      metaTicketMedio = 0; // Valor padr√£o em caso de erro
    }

    // üéØ DADOS ANTERIORES - Buscar dados do per√≠odo anterior para compara√ß√£o
    console.log('üìä Buscando dados do per√≠odo anterior para compara√ß√£o...');
    const dadosAnteriores = await getTicketMedioAnteriores(dataInicio, dataFim, selectedFunnel, selectedUnit, selectedSeller, selectedOrigin);

    // üéØ CALCULAR PERCENTUAL DA META (ticket m√©dio do per√≠odo vs meta em R$)
    const percentualMeta = metaTicketMedio > 0 ? 
      ((ticketMedioPeriodo - metaTicketMedio) / metaTicketMedio) * 100 : 0;
    
    console.log(`üìä C√°lculo do percentual da meta:`);
    console.log(`   - Ticket M√©dio do Per√≠odo: R$ ${ticketMedioPeriodo.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`);
    console.log(`   - Meta: R$ ${metaTicketMedio.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`);
    console.log(`   - Percentual: ${percentualMeta.toFixed(2)}%`);

    // üéØ FORMATAR DADOS PARA O COMPONENTE
    const metrics = {
      ticketMedioPeriodo: {
        current: Math.round(ticketMedioPeriodo), // N√∫mero principal: ticket m√©dio do per√≠odo
        previous: dadosAnteriores.ticketMedioPeriodo,
        value: ticketMedioPeriodo, // Valor decimal para c√°lculos
        meta: metaTicketMedio, // Meta real da tabela metas
        metaPercentage: percentualMeta, // Percentual calculado: (ticket m√©dio - meta) / meta * 100
        change: dadosAnteriores.ticketMedioPeriodo > 0 ? 
          ((ticketMedioPeriodo - dadosAnteriores.ticketMedioPeriodo) / dadosAnteriores.ticketMedioPeriodo) * 100 : 0,
        isPositive: ticketMedioPeriodo >= dadosAnteriores.ticketMedioPeriodo // Para ticket m√©dio, mais √© melhor
      },
      ticketMedioGeral: {
        current: Math.round(ticketMedioGeral), // N√∫mero principal: ticket m√©dio geral
        previous: dadosAnteriores.ticketMedioGeral,
        value: ticketMedioGeral, // Valor decimal para c√°lculos
        meta: metaTicketMedio, // Meta real da tabela metas
        metaPercentage: percentualMeta, // Percentual calculado: (ticket m√©dio - meta) / meta * 100
        change: dadosAnteriores.ticketMedioGeral > 0 ? 
          ((ticketMedioGeral - dadosAnteriores.ticketMedioGeral) / dadosAnteriores.ticketMedioGeral) * 100 : 0,
        isPositive: ticketMedioGeral >= dadosAnteriores.ticketMedioGeral // Para ticket m√©dio, mais √© melhor
      }
    };

    console.log('‚úÖ TicketMedioService: M√©tricas calculadas:', metrics);
    return metrics;

  } catch (error) {
    console.error('‚ùå Erro no TicketMedioService:', error);
    throw error;
  }
};

/**
 * üü£ BUSCAR DADOS DO PER√çODO ANTERIOR (para compara√ß√£o)
 */
const getTicketMedioAnteriores = async (dataInicio, dataFim, selectedFunnel, selectedUnit, selectedSeller, selectedOrigin) => {
  try {
    // Calcular per√≠odo anterior
    const startDate = new Date(dataInicio);
    const endDate = new Date(dataFim);
    const diffTime = endDate.getTime() - startDate.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    const startAnterior = new Date(startDate);
    startAnterior.setDate(startAnterior.getDate() - diffDays - 1);
    
    const endAnterior = new Date(endDate);
    endAnterior.setDate(endAnterior.getDate() - diffDays - 1);
    
    const dataInicioAnterior = startAnterior.toISOString().split('T')[0];
    const dataFimAnterior = endAnterior.toISOString().split('T')[0];
    
    console.log('üìÖ Per√≠odo anterior - ticket m√©dio:', { dataInicioAnterior, dataFimAnterior });

    // Construir filtros
    const funilFilter = selectedFunnel && selectedFunnel !== 'all' && selectedFunnel !== 'TODOS' ? `&funil_id=eq.${selectedFunnel}` : `&funil_id=in.(6,14)`;
    const unidadeFilter = selectedUnit && selectedUnit !== 'all' ? `&unidade_id=eq.${encodeURIComponent(selectedUnit.toString())}` : '';
    const sellerFilter = selectedSeller && selectedSeller !== 'all' ? `&user_id=eq.${selectedSeller}` : '';
    
    // Filtro de origem (mesma l√≥gica da fun√ß√£o principal)
    let originFilter = '';
    if (selectedOrigin && selectedOrigin !== 'all') {
      try {
        const originResponse = await fetch(`${supabaseUrl}/rest/v1/origem_oportunidade?select=nome&id=eq.${selectedOrigin}`, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Authorization': `Bearer ${supabaseServiceKey}`,
            'apikey': supabaseServiceKey,
            'Accept-Profile': supabaseSchema,
          }
        });

        if (originResponse.ok) {
          const originData = await originResponse.json();
          if (originData && originData.length > 0) {
            const originName = originData[0].nome;
            
            const lower = originName.toLowerCase();
            if (lower === 'org√¢nico' || lower === 'organico') {
              originFilter = `&or=(origem_oportunidade.eq.${encodeURIComponent(originName)},origem_oportunidade.is.null)`;
            } else if (lower === 'google ads' || lower === 'googleads') {
              originFilter = `&or=(origem_oportunidade.eq.${encodeURIComponent(originName)},utm_source.eq.google,utm_source.eq.GoogleAds)`;
            } else {
              originFilter = `&origem_oportunidade=eq.${encodeURIComponent(originName)}`;
            }
          }
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Erro ao buscar origem no per√≠odo anterior:', error);
        originFilter = `&origem_oportunidade=eq.${encodeURIComponent(selectedOrigin)}`;
      }
    }

    const filtrosCombinados = funilFilter + unidadeFilter + sellerFilter + originFilter;

    // URLs para per√≠odo anterior
    const ticketMedioPeriodoAnteriorUrl = `${supabaseUrl}/rest/v1/oportunidade_sprint?select=id,value&archived=eq.0&status=eq.gain&gain_date=gte.${dataInicioAnterior}&gain_date=lte.${dataFimAnterior}T23:59:59${filtrosCombinados}`;
    const ticketMedioGeralAnteriorUrl = `${supabaseUrl}/rest/v1/oportunidade_sprint?select=id,value&archived=eq.0&status=eq.gain${filtrosCombinados}`;

    // üü£ EXECUTAR QUERIES COM PAGINA√á√ÉO PARA DADOS ANTERIORES
    const baseHeaders = {
      'Accept': 'application/json',
      'Authorization': `Bearer ${supabaseServiceKey}`,
      'apikey': supabaseServiceKey,
      'Accept-Profile': supabaseSchema,
      'Prefer': 'count=exact'
    };

    // Executar queries com pagina√ß√£o em paralelo
    const [periodoAnteriorData, geralAnteriorData] = await Promise.all([
      fetchAllRecords(ticketMedioPeriodoAnteriorUrl, baseHeaders),
      fetchAllRecords(ticketMedioGeralAnteriorUrl, baseHeaders)
    ]);

    let ticketMedioPeriodoAnterior = 0;
    let ticketMedioGeralAnterior = 0;

    // Processar ticket m√©dio do per√≠odo anterior - usando pagina√ß√£o
    if (periodoAnteriorData && Array.isArray(periodoAnteriorData)) {
      const quantidadeAnterior = periodoAnteriorData.length;
      const valorTotalAnterior = periodoAnteriorData.reduce((total, opp) => {
        const valor = parseFloat(opp.value) || 0;
        return total + valor;
      }, 0);
      
      ticketMedioPeriodoAnterior = quantidadeAnterior > 0 ? valorTotalAnterior / quantidadeAnterior : 0;
    }

    // Processar ticket m√©dio geral anterior - usando pagina√ß√£o
    if (geralAnteriorData && Array.isArray(geralAnteriorData)) {
      const quantidadeGeralAnterior = geralAnteriorData.length;
      const valorTotalGeralAnterior = geralAnteriorData.reduce((total, opp) => {
        const valor = parseFloat(opp.value) || 0;
        return total + valor;
      }, 0);
      
      ticketMedioGeralAnterior = quantidadeGeralAnterior > 0 ? valorTotalGeralAnterior / quantidadeGeralAnterior : 0;
    }

    return {
      ticketMedioPeriodo: Math.round(ticketMedioPeriodoAnterior),
      ticketMedioGeral: Math.round(ticketMedioGeralAnterior)
    };

  } catch (error) {
    console.error('‚ùå Erro ao buscar dados anteriores do ticket m√©dio:', error);
    return {
      ticketMedioPeriodo: 0,
      ticketMedioGeral: 0
    };
  }
};
