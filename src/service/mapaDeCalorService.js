/**
 * üî• MAPA DE CALOR SERVICE - VERS√ÉO CORRIGIDA
 *
 * Service para buscar dados de leads agrupados por dia da semana e hora
 * seguindo EXATAMENTE a mesma l√≥gica do DailyPerformanceVertical
 *
 * L√ìGICA:
 * - Dados criados das 7h √†s 8h ‚Üí aparecem no quadro das 8h
 * - Dados criados das 8h √†s 9h ‚Üí aparecem no quadro das 9h
 * - E assim por diante...
 * - Usar create_date para leads (n√£o gain_date)
 */

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseServiceKey = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY;
const supabaseSchema = import.meta.env.VITE_SUPABASE_SCHEMA || 'api';

/**
 * Fun√ß√£o auxiliar para adicionar dias a uma data
 */
const addDays = (dateString, days) => {
  const date = new Date(dateString + 'T00:00:00');
  date.setDate(date.getDate() + days);
  return date.toISOString().split('T')[0];
};

/**
 * Fun√ß√£o para buscar TODOS os dados com pagina√ß√£o autom√°tica (supera limite 1000)
 */
const fetchAllDataWithPagination = async (baseQuery) => {
  console.log('üîÑ INICIANDO PAGINA√á√ÉO AUTOM√ÅTICA...');

  let allData = [];
  let offset = 0;
  const limit = 1000;
  let hasMore = true;

  while (hasMore) {
    const paginatedQuery = `${baseQuery}&limit=${limit}&offset=${offset}`;
    console.log(`üìÑ P√°gina ${Math.floor(offset/limit) + 1}: ${supabaseUrl}/rest/v1/${paginatedQuery}`);

    try {
      const response = await fetch(`${supabaseUrl}/rest/v1/${paginatedQuery}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Authorization': `Bearer ${supabaseServiceKey}`,
          'apikey': supabaseServiceKey,
          'Accept-Profile': 'api',
          'Content-Profile': 'api'
        }
      });

      if (!response.ok) {
        console.error(`‚ùå Erro na p√°gina ${Math.floor(offset/limit) + 1}:`, response.status);
        break;
      }

      const pageData = await response.json();
      allData = allData.concat(pageData);

      console.log(`‚úÖ P√°gina ${Math.floor(offset/limit) + 1}: ${pageData.length} registros`);

      // Se retornou menos que o limite, chegamos ao fim
      if (pageData.length < limit) {
        hasMore = false;
        console.log('üèÅ PAGINA√á√ÉO CONCLU√çDA - Chegou ao fim dos dados');
      } else {
        offset += limit;
        console.log(`‚û°Ô∏è Continuando para p√°gina ${Math.floor(offset/limit) + 1}...`);
      }

    } catch (error) {
      console.error('‚ùå Erro na pagina√ß√£o:', error);
      break;
    }
  }

  console.log(`üéØ PAGINA√á√ÉO FINALIZADA: ${allData.length} registros totais`);
  return allData;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar a √∫ltima segunda-feira (com offset de semanas)
 */
const getLastMonday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltima segunda-feira (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastMonday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© segunda-feira (1), usar hoje
  if (today.getDay() === 1) {
    console.log(`‚úÖ √â SEGUNDA-FEIRA: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar a √∫ltima segunda-feira
  while (lastMonday.getDay() !== 1) {
    lastMonday.setDate(lastMonday.getDate() - 1);
  }

  const mondayString = lastMonday.toISOString().split('T')[0];
  console.log(`‚úÖ SEGUNDA-FEIRA ENCONTRADA (offset ${weekOffset}): ${mondayString}`);

  return mondayString;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar a √∫ltima ter√ßa-feira (com offset de semanas)
 */
const getLastTuesday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltima ter√ßa-feira (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastTuesday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© ter√ßa-feira (2), usar hoje
  if (today.getDay() === 2) {
    console.log(`‚úÖ √â TER√áA-FEIRA: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar a √∫ltima ter√ßa-feira
  while (lastTuesday.getDay() !== 2) {
    lastTuesday.setDate(lastTuesday.getDate() - 1);
  }

  const tuesdayString = lastTuesday.toISOString().split('T')[0];
  console.log(`‚úÖ TER√áA-FEIRA ENCONTRADA (offset ${weekOffset}): ${tuesdayString}`);

  return tuesdayString;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar a √∫ltima quarta-feira (com offset de semanas)
 */
const getLastWednesday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltima quarta-feira (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastWednesday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© quarta-feira (3), usar hoje
  if (today.getDay() === 3) {
    console.log(`‚úÖ √â QUARTA-FEIRA: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar a √∫ltima quarta-feira
  while (lastWednesday.getDay() !== 3) {
    lastWednesday.setDate(lastWednesday.getDate() - 1);
  }

  const wednesdayString = lastWednesday.toISOString().split('T')[0];
  console.log(`‚úÖ QUARTA-FEIRA ENCONTRADA (offset ${weekOffset}): ${wednesdayString}`);

  return wednesdayString;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar a √∫ltima quinta-feira (com offset de semanas)
 */
const getLastThursday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltima quinta-feira (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastThursday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© quinta-feira (4), usar hoje
  if (today.getDay() === 4) {
    console.log(`‚úÖ √â QUINTA-FEIRA: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar a √∫ltima quinta-feira
  while (lastThursday.getDay() !== 4) {
    lastThursday.setDate(lastThursday.getDate() - 1);
  }

  const thursdayString = lastThursday.toISOString().split('T')[0];
  console.log(`‚úÖ QUINTA-FEIRA ENCONTRADA (offset ${weekOffset}): ${thursdayString}`);

  return thursdayString;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar a √∫ltima sexta-feira (com offset de semanas)
 */
const getLastFriday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltima sexta-feira (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastFriday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© sexta-feira (5), usar hoje
  if (today.getDay() === 5) {
    console.log(`‚úÖ √â SEXTA-FEIRA: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar a √∫ltima sexta-feira
  while (lastFriday.getDay() !== 5) {
    lastFriday.setDate(lastFriday.getDate() - 1);
  }

  const fridayString = lastFriday.toISOString().split('T')[0];
  console.log(`‚úÖ SEXTA-FEIRA ENCONTRADA (offset ${weekOffset}): ${fridayString}`);

  return fridayString;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar o √∫ltimo s√°bado (com offset de semanas)
 */
const getLastSaturday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltimo s√°bado (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastSaturday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© s√°bado (6), usar hoje
  if (today.getDay() === 6) {
    console.log(`‚úÖ √â S√ÅBADO: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar o √∫ltimo s√°bado
  while (lastSaturday.getDay() !== 6) {
    lastSaturday.setDate(lastSaturday.getDate() - 1);
  }

  const saturdayString = lastSaturday.toISOString().split('T')[0];
  console.log(`‚úÖ S√ÅBADO ENCONTRADO (offset ${weekOffset}): ${saturdayString}`);

  return saturdayString;
};

/**
 * Fun√ß√£o SIMPLES: sempre buscar o √∫ltimo domingo (com offset de semanas)
 */
const getLastSunday = (weekOffset = 0) => {
  console.log(`üìÖ MAPA DE CALOR: Calculando √∫ltimo domingo (weekOffset: ${weekOffset})`);

  const today = new Date();
  // Aplicar offset de semanas (weekOffset * 7 dias)
  today.setDate(today.getDate() - (weekOffset * 7));

  let lastSunday = new Date(today);

  console.log(`üìÖ Data base (com offset): ${today.toISOString().split('T')[0]} (dia da semana: ${today.getDay()})`);

  // Se hoje √© domingo (0), usar hoje
  if (today.getDay() === 0) {
    console.log(`‚úÖ √â DOMINGO: usando ${today.toISOString().split('T')[0]}`);
    return today.toISOString().split('T')[0];
  }

  // Sen√£o, voltar at√© encontrar o √∫ltimo domingo
  while (lastSunday.getDay() !== 0) {
    lastSunday.setDate(lastSunday.getDate() - 1);
  }

  const sundayString = lastSunday.toISOString().split('T')[0];
  console.log(`‚úÖ DOMINGO ENCONTRADO (offset ${weekOffset}): ${sundayString}`);

  return sundayString;
};

/**
 * Construir filtros (mesma l√≥gica do TotalOportunidadesService)
 */
const buildFilters = async (selectedFunnel, selectedUnit, selectedSeller, selectedOrigin) => {
  let funilFilter = '';
  if (selectedFunnel && selectedFunnel !== 'all' && selectedFunnel !== 'TODOS' && selectedFunnel !== '' && selectedFunnel !== 'undefined') {
    funilFilter = `&funil_id=eq.${selectedFunnel}`;
  } else {
    funilFilter = `&funil_id=in.(6,14)`;
  }

  let unidadeFilter = '';
  if (selectedUnit && selectedUnit !== 'all' && selectedUnit !== '' && selectedUnit !== 'undefined') {
    const unidadeValue = selectedUnit.toString();
    const unidadeEncoded = encodeURIComponent(unidadeValue);
    unidadeFilter = `&unidade_id=eq.${unidadeEncoded}`;
  }

  let sellerFilter = '';
  if (selectedSeller && selectedSeller !== 'all' && selectedSeller !== '' && selectedSeller !== 'undefined') {
    sellerFilter = `&user_id=eq.${selectedSeller}`;
  }

  let originFilter = '';
  if (selectedOrigin && selectedOrigin !== 'all' && selectedOrigin !== '' && selectedOrigin !== 'undefined') {
    try {
      const originResponse = await fetch(`${supabaseUrl}/rest/v1/origem_oportunidade?select=nome&id=eq.${selectedOrigin}`, {
        method: 'GET',
        headers: {
          'Accept': 'application/json',
          'Authorization': `Bearer ${supabaseServiceKey}`,
          'apikey': supabaseServiceKey,
          'Accept-Profile': 'api',
        }
      });

      if (originResponse.ok) {
        const originData = await originResponse.json();
        if (originData && originData.length > 0) {
          const originName = originData[0].nome;
          const lower = originName.toLowerCase();

          if (lower === 'org√¢nico' || lower === 'organico') {
            originFilter = `&or=(origem_oportunidade.eq.${encodeURIComponent(originName)},origem_oportunidade.is.null)`;
          } else if (lower === 'google ads' || lower === 'googleads') {
            originFilter = `&or=(origem_oportunidade.eq.${encodeURIComponent(originName)},utm_source.eq.google,utm_source.eq.GoogleAds)`;
          } else {
            originFilter = `&origem_oportunidade=eq.${encodeURIComponent(originName)}`;
          }
        }
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Erro ao buscar origem, usando ID diretamente:', error);
      originFilter = `&origem_oportunidade=eq.${encodeURIComponent(selectedOrigin)}`;
    }
  }

  return funilFilter + unidadeFilter + sellerFilter + originFilter;
};

/**
 * Buscar dados de um dia espec√≠fico (COM PAGINA√á√ÉO AUTOM√ÅTICA)
 */
const fetchDayData = async (nomeDay, dateString, filtrosCombinados, rawLeadsData, key) => {
  console.log(`üéØ BUSCANDO DADOS DE ${nomeDay.toUpperCase()}: ${dateString}`);

  const totalDiaQuery = `oportunidade_sprint?select=id,value&archived=eq.0&create_date=gte.${dateString}&create_date=lte.${dateString}T23:59:59${filtrosCombinados}`;

  console.log(`üîç Query ${nomeDay}:`, `${supabaseUrl}/rest/v1/${totalDiaQuery}`);

  try {
    // üîÑ USAR PAGINA√á√ÉO AUTOM√ÅTICA
    const totalDiaLeads = await fetchAllDataWithPagination(totalDiaQuery);
    rawLeadsData[key] = totalDiaLeads;
    console.log(`üéØ TOTAL ${nomeDay.toUpperCase()}: ${totalDiaLeads.length} leads encontrados (COM PAGINA√á√ÉO)`);
  } catch (error) {
    console.error(`‚ùå Erro ao buscar dados de ${nomeDay}:`, error);
    rawLeadsData[key] = [];
  }
};

/**
 * Buscar dados por hora para um dia espec√≠fico
 */
const fetchHourlyData = async (dateString, diaSemana, horarios, filtrosCombinados, heatmapData, nomeDay) => {
  console.log(`üéØ PROCESSANDO HORAS DE ${nomeDay.toUpperCase()}: ${dateString}`);

  for (const horaFim of horarios) {
    const horaInicio = horaFim - 1; // Das 7h √†s 8h = mostra no quadro 8h

    console.log(`üéØ ${nomeDay} - HORA ${horaFim}h (dados criados das ${horaInicio}h √†s ${horaFim}h)`);

    // BUSCA LEADS por hora
    let leadsQuery = `oportunidade_sprint?select=id,create_date&archived=eq.0`;

    // Aplicar filtro de hor√°rio
    const horaInicioStr = `${String(horaInicio).padStart(2, '0')}:00:00`;
    const horaFimStr = `${String(horaFim).padStart(2, '0')}:00:00`;

    const dataInicio = `${dateString}T${horaInicioStr}`;
    const dataFim = `${dateString}T${horaFimStr}`;

    leadsQuery += `&create_date=gte.${dataInicio}&create_date=lt.${dataFim}`;
    leadsQuery += filtrosCombinados;

    console.log(`üîç Query ${nomeDay} ${horaFim}h:`, `${supabaseUrl}/rest/v1/${leadsQuery}`);

    // üîÑ EXECUTAR BUSCA COM PAGINA√á√ÉO AUTOM√ÅTICA
    let leadsCount = 0;

    try {
      const horaLeads = await fetchAllDataWithPagination(leadsQuery);
      leadsCount = horaLeads.length;
      console.log(`üéØ ${nomeDay} ${horaFim}h: ${leadsCount} leads encontrados (COM PAGINA√á√ÉO)`);
    } catch (error) {
      console.error(`‚ùå Erro ao buscar leads ${nomeDay} hora ${horaFim}h:`, error);
    }

    // Adicionar ao array de dados processados
    heatmapData.push({
      dia_semana: diaSemana,
      hora: horaFim,
      total_leads: leadsCount
    });
  }
};

/**
 * Buscar dados do mapa de calor seguindo l√≥gica do DailyPerformanceVertical
 * @param {Object} params - Par√¢metros de filtro
 */
export const getMapaDeCalorData = async (params) => {
  try {
    const { startDate, endDate, selectedFunnel, selectedUnit, selectedSeller, selectedOrigin, weekOffset = 0 } = params;

    console.log('üî• MapaDeCalor: Buscando dados com l√≥gica h√≠brida...', params);
    console.log(`üéØ WeekOffset: ${weekOffset} - ${weekOffset === 0 ? 'SEMANA ATUAL (esparramada)' : 'SEMANA ANTERIOR (sequencial)'}`);

    let mondayDate, tuesdayDate, wednesdayDate, thursdayDate, fridayDate, saturdayDate, sundayDate;

    if (weekOffset === 0) {
      // üéØ SEMANA ATUAL: L√≥gica esparramada (√∫ltima ocorr√™ncia de cada dia)
      console.log('üî• USANDO L√ìGICA ESPARRAMADA (semana atual)');
      mondayDate = getLastMonday(0);
      tuesdayDate = getLastTuesday(0);
      wednesdayDate = getLastWednesday(0);
      thursdayDate = getLastThursday(0);
      fridayDate = getLastFriday(0);
      saturdayDate = getLastSaturday(0);
      sundayDate = getLastSunday(0);
    } else {
      // üéØ SEMANAS ANTERIORES: L√≥gica sequencial (semana calend√°rio)
      console.log(`üî• USANDO L√ìGICA SEQUENCIAL (${weekOffset} semana${weekOffset > 1 ? 's' : ''} atr√°s)`);
      const baseMondayDate = getLastMonday(weekOffset);

      mondayDate = baseMondayDate;                    // Segunda-feira base
      tuesdayDate = addDays(baseMondayDate, 1);      // Segunda + 1 dia
      wednesdayDate = addDays(baseMondayDate, 2);    // Segunda + 2 dias
      thursdayDate = addDays(baseMondayDate, 3);     // Segunda + 3 dias
      fridayDate = addDays(baseMondayDate, 4);       // Segunda + 4 dias
      saturdayDate = addDays(baseMondayDate, 5);     // Segunda + 5 dias
      sundayDate = addDays(baseMondayDate, 6);       // Segunda + 6 dias

      console.log(`üìÖ SEMANA SEQUENCIAL CALCULADA (base: ${baseMondayDate}):`);
    }
    console.log(`üéØ DATAS FIXAS PARA HEATMAP:`);
    console.log(`   üìÖ Segunda-feira: ${mondayDate}`);
    console.log(`   üìÖ Ter√ßa-feira: ${tuesdayDate}`);
    console.log(`   üìÖ Quarta-feira: ${wednesdayDate}`);
    console.log(`   üìÖ Quinta-feira: ${thursdayDate}`);
    console.log(`   üìÖ Sexta-feira: ${fridayDate}`);
    console.log(`   üìÖ S√°bado: ${saturdayDate}`);
    console.log(`   üìÖ Domingo: ${sundayDate}`);

    // Array para armazenar dados por hora
    const heatmapData = [];
    const rawLeadsData = {
      segunda: [],
      terca: [],
      quarta: [],
      quinta: [],
      sexta: [],
      sabado: [],
      domingo: [],
      segundaDate: mondayDate,
      tercaDate: tuesdayDate,
      quartaDate: wednesdayDate,
      quintaDate: thursdayDate,
      sextaDate: fridayDate,
      sabadoDate: saturdayDate,
      domingoDate: sundayDate
    };

    // Definir hor√°rios fixos de 8h √†s 22h (seguindo padr√£o do mapa de calor)
    const horarios = [];
    for (let hora = 8; hora <= 22; hora++) {
      horarios.push(hora);
    }

    console.log('üéØ PROCESSANDO HOR√ÅRIOS:', horarios);

    // BUSCAR DADOS DE TODOS OS DIAS DA SEMANA
    console.log('üéØ BUSCANDO DADOS DE TODA A SEMANA...');

    // Construir filtros (mesma l√≥gica do TotalOportunidadesService)
    const filtrosCombinados = await buildFilters(selectedFunnel, selectedUnit, selectedSeller, selectedOrigin);

    // BUSCAR DADOS TOTAIS POR DIA
    await fetchDayData('segunda-feira', mondayDate, filtrosCombinados, rawLeadsData, 'segunda');
    await fetchDayData('ter√ßa-feira', tuesdayDate, filtrosCombinados, rawLeadsData, 'terca');
    await fetchDayData('quarta-feira', wednesdayDate, filtrosCombinados, rawLeadsData, 'quarta');
    await fetchDayData('quinta-feira', thursdayDate, filtrosCombinados, rawLeadsData, 'quinta');
    await fetchDayData('sexta-feira', fridayDate, filtrosCombinados, rawLeadsData, 'sexta');
    await fetchDayData('s√°bado', saturdayDate, filtrosCombinados, rawLeadsData, 'sabado');
    await fetchDayData('domingo', sundayDate, filtrosCombinados, rawLeadsData, 'domingo');

    // BUSCAR DADOS POR HORA PARA TODA A SEMANA
    await fetchHourlyData(mondayDate, 1, horarios, filtrosCombinados, heatmapData, 'Segunda-feira');
    await fetchHourlyData(tuesdayDate, 2, horarios, filtrosCombinados, heatmapData, 'Ter√ßa-feira');
    await fetchHourlyData(wednesdayDate, 3, horarios, filtrosCombinados, heatmapData, 'Quarta-feira');
    await fetchHourlyData(thursdayDate, 4, horarios, filtrosCombinados, heatmapData, 'Quinta-feira');
    await fetchHourlyData(fridayDate, 5, horarios, filtrosCombinados, heatmapData, 'Sexta-feira');
    await fetchHourlyData(saturdayDate, 6, horarios, filtrosCombinados, heatmapData, 'S√°bado');
    await fetchHourlyData(sundayDate, 0, horarios, filtrosCombinados, heatmapData, 'Domingo');

    console.log('‚úÖ MapaDeCalor: Processamento conclu√≠do');
    console.log('üìä Dados por hora:', heatmapData);
    console.log('üìä Totais por dia:', {
      segunda: rawLeadsData.segunda ? rawLeadsData.segunda.length : 0,
      terca: rawLeadsData.terca ? rawLeadsData.terca.length : 0,
      quarta: rawLeadsData.quarta ? rawLeadsData.quarta.length : 0,
      quinta: rawLeadsData.quinta ? rawLeadsData.quinta.length : 0,
      sexta: rawLeadsData.sexta ? rawLeadsData.sexta.length : 0,
      sabado: rawLeadsData.sabado ? rawLeadsData.sabado.length : 0,
      domingo: rawLeadsData.domingo ? rawLeadsData.domingo.length : 0
    });

    // Calcular totais
    const totalPorHora = heatmapData.reduce((sum, item) => sum + item.total_leads, 0);
    const totalSegunda = rawLeadsData.segunda ? rawLeadsData.segunda.length : 0;
    const totalTerca = rawLeadsData.terca ? rawLeadsData.terca.length : 0;
    const totalQuarta = rawLeadsData.quarta ? rawLeadsData.quarta.length : 0;
    const totalQuinta = rawLeadsData.quinta ? rawLeadsData.quinta.length : 0;
    const totalSexta = rawLeadsData.sexta ? rawLeadsData.sexta.length : 0;
    const totalSabado = rawLeadsData.sabado ? rawLeadsData.sabado.length : 0;
    const totalDomingo = rawLeadsData.domingo ? rawLeadsData.domingo.length : 0;

    console.log('üéØ TOTAIS CALCULADOS:');
    console.log(`   - Soma c√©lulas por hora: ${totalPorHora}`);
    console.log(`   - Total Segunda-feira: ${totalSegunda}`);
    console.log(`   - Total Ter√ßa-feira: ${totalTerca}`);
    console.log(`   - Total Quarta-feira: ${totalQuarta}`);
    console.log(`   - Total Quinta-feira: ${totalQuinta}`);
    console.log(`   - Total Sexta-feira: ${totalSexta}`);
    console.log(`   - Total S√°bado: ${totalSabado}`);
    console.log(`   - Total Domingo: ${totalDomingo}`);

    return {
      heatmapData: heatmapData,
      rawData: rawLeadsData, // Estrutura com todos os 7 dias da semana
      totalLeads: totalSegunda + totalTerca + totalQuarta + totalQuinta + totalSexta + totalSabado + totalDomingo
    };

  } catch (error) {
    console.error('‚ùå Erro ao buscar dados do mapa de calor:', error);

    return {
      heatmapData: [],
      rawData: [],
      totalLeads: 0
    };
  }
};